package main

import (
	"errors"
	"fmt"
	"html/template"
	"io/ioutil"
	"log"
	"net/http"
	"regexp"
)

// Template named follow with the template filename
// var templates = template.Must(template.ParseFiles("edit.hml", "view.html", "save.html"))

var validPath = regexp.MustCompile("^/(edit|save|view)/([a-zA-Z0-9]+)$")

// ^ 	start
// () 	group
// []   any
// -    between
// +    one or more
// | 	alternate (or)
// $ 	end

// html/template package
// 1. to keep the HTML in seperate file, allowing us to change the layout without modifying undlying code go
// 2. guarantee that only safe and correct-looking HTML is generated by template action (or execute)

type Page struct {
	Title string
	Body  []byte
}

func (p *Page) save() error {
	fileName := p.Title + ".txt"
	// WriteFile : filename, bytes, permission bits
	err := ioutil.WriteFile(fileName, p.Body, 0600) // It's file and owner can read (2) and write (4)
	return err
}

const (
	ViewPath = "/view/"
	EditPath = "/edit/"
	SavePath = "/save/"
)

// 1. View a wiki page
func viewHandler(res http.ResponseWriter, req *http.Request) {
	// Get page title from URL path prefix with /view/
	// Ex :
	// http://example.com/view/hello
	// title = hello

	// title := req.URL.Path[len(ViewPath):]

	// Get title from regex
	title, err := getTitle(res, req)
	if err != nil {
		return
	}

	p, _ := loadPage(title)
	if p == nil { // page doesn't exist
		// redirect to create a new page
		http.Redirect(res, req, "/edit/"+title, http.StatusFound)
		return
	}
	// fmt.Fprintf(res, "<h1>%s</h1><p>%s</p>", p.Title, p.Body)

	// Use the template instead of hardcoded HTML
	renderHTML(res, "view", p)
}

// 2. Display an "edit page" form
func editHandler(res http.ResponseWriter, req *http.Request) {
	// title := req.URL.Path[len(EditPath):]

	// Get title from regex
	title, err := getTitle(res, req)
	if err != nil {
		return
	}

	p, _ := loadPage(title)
	if p == nil { // page doesn't exist
		// create a new page
		p = &Page{
			Title: title,
			Body:  []byte{},
		}
	}

	// fmt.Fprintf(res, `<h1>Editing %s</h1>`+
	// 	`<form action="/save/%s" method="POST">`+
	// 	`<textarea name="body">%s</textarea>`+
	// 	`<input type="submit" value="Save">`+
	// 	`</form>`, p.Title, p.Title, p.Body)

	// Use the template instead of hardcoded HTML
	renderHTML(res, "edit", p)
}

// 3. Save data from page form
func saveHandler(res http.ResponseWriter, req *http.Request) {
	// Get page title from submitted action URL path prefix with /save/

	// title := req.URL.Path[len(SavePath):]

	// Get title from regex
	title, err := getTitle(res, req)
	if err != nil {
		return
	}

	// Get form value from name body
	body := req.FormValue("body")

	p := &Page{Title: title, Body: []byte(body)}
	err = p.save()
	if err != nil {
		fmt.Println("Failed to save", err)
		http.Error(res, "Failed to save", http.StatusInternalServerError)
		return
	}

	// fmt.Fprintf(res, `<p>Successfully saved %s</p><a href="/view/%s">View</p>`, title, title)

	// Use the template instead of hardcoded HTML
	// renderHTML(res, "save", p)

	// Use redirect to view the saved page
	http.Redirect(res, req, "/view/"+title, http.StatusFound)
}

// Load page from a file
func loadPage(title string) (*Page, error) {
	fileName := title + ".txt"
	fileContent, err := ioutil.ReadFile(fileName)
	if err != nil {
		return nil, err
	} else {
		return &Page{
			Title: title,
			Body:  fileContent,
		}, nil
	}
}

// Error Handling ?
// There is an error means something wrong about our program
// 1. Fix the error, but can't do immediatelly if already in prod environment (there is deployment effort)
//    Better solution, to show the errors both in server (print stack trace) and client - (status code and short info)
//    and latter developer can fix the error

func renderHTML(res http.ResponseWriter, name string, p *Page) { // p possibly to nil, if page can't be loaded
	// t, err := template.ParseFiles(name + ".html")
	// if err != nil {
	// 	log.Println("Failed to parse", err)
	// 	http.Error(res, "Failed to parse", http.StatusInternalServerError) // Internal Server Error - 500
	// 	return
	// } else {
	// err = t.Execute(res, p)

	// Execute the template, writing the generated HTML from name.html and
	// *mapping the attribute* from p value - its called template directives
	// Mapping the attribute ?
	// {{.Title}} 		 - p.Title
	// {{.Body}}  		 - p.Body
	// printf "%s" .Body - output the p.Body as string instead of bytes
	// Similar to :
	// fmt.Printf("%s", p.Body)

	// Use template caching instead,
	var templates, _ = template.ParseFiles(name + ".html")
	err := templates.Execute(res, p)
	if err != nil {
		log.Println("Failed to generate", err)
		http.Error(res, "Failed to generate", http.StatusInternalServerError)
	}
	// }
}

func getTitle(w http.ResponseWriter, r *http.Request) (string, error) {
	g := validPath.FindStringSubmatch(r.URL.Path) // result as group of matches
	// Ex : ^/(edit|save|view)/([a-zA-Z0-9]+)$
	//       /edit/title
	// group 0 = /edit/title
	// group 1 = edit
	// group 2 = title

	if g == nil { // nil indicate no match
		http.NotFound(w, r)
		return "", errors.New("Unmatched title with exp : " + validPath.String())
	}
	return g[2], nil // get group 2 as title
}

func main() {
	// Handle for all request to the URL path ("/view/")
	http.HandleFunc(ViewPath, viewHandler)
	// Handle for all request to the URL path ("/edit/")
	http.HandleFunc(EditPath, editHandler)
	// Handle for all request to the URL path ("/save/")
	http.HandleFunc(SavePath, saveHandler)
	// Server listen to port 8080
	err := http.ListenAndServe(":8080", nil)
	if err != nil {
		log.Fatal(err)
	}
}
